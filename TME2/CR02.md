# Compte Rendu TME2

## Driver pour les LEDs et le bouton poussoir

Nous allons créer un pilote pour contrôler les LEDs sans devoir exécuter le programme avec droits d'administrateur avec `sudo`. Le pilote sera sauvegardé dans le répertoire des dispositifs `/dev/led0_TM`.

## Étape 1 : création et test d'un module noyau

### Questions
- Quelle fonction est exécutée lorsqu'on insère le module du noyau ?
    `mon_module_init()`
- Quelle fonction est exécutée lorsqu'on enlève le module du noyau ? 
    `mon_module_cleanup()`

Nous avons compilé le module en utilisant le librairie du noyau de la RPI. Ensuite, nous avons inseré le module avec les commandes suivantes :

```
$ sudo insmod ./module.ko : Insére le module compilé au noyau
$ lsmod : On affiche les modules installés afin de vérifier que notre module est bien là
$ dmesg : Affiche les messages du système informe du travail réalisé
$ sudo rmmod module : Décharge le module du noyau
$ lsmod : On affiche les modules installés afin de vérifier que notre module n'est plus là
$ dmesg
```

## Étape 2 : ajout des paramètres au module

### Parametre bouton

```c
static int btn;
module_param(btn, int, 0);
MODULE_PARM_DESC(btn, "numéro du port du bouton");

static int __init mon_module_init(void)
{
    printk(KERN_DEBUG "Hello World !\n");
    printk(KERN_DEBUG "btn=%d !\n", btn);
    return 0;
}
```

```
$ sudo insmod ./module.ko btn=18
```


Afind e vérifier blah blah 

```
pi@raspberrypi ~/thirion_mendieta/lab2 $ modinfo module.ko
filename:       /home/pi/thirion_mendieta/lab2/module.ko
description:    Module pour contrôler une LED
author:         Jorge MENDIETA, Lou THIRION
license:        GPL
srcversion:     7277E7B09B4E23DE94A5654
depends:        
vermagic:       3.18.7 preempt mod_unload modversions ARMv6 
parm:           btn:numéro du port du bouton (int)
```

### Tableau de Parametres LEDs

```c
// led parameter
#define NBMAX_LED 32
static int leds[NBMAX_LED];
static int nbled;
module_param_array(leds, int, &nbled, 0);
MODULE_PARM_DESC(LEDS, "tableau des numéros de port LED");
```
dans la fonction init

```c
   int i;
   for (i = 0; i < nbled; i++)
       printk(KERN_DEBUG "LED %d = %d\n", i, leds[i]);

```

Après il faut recompiler et recopier le module, rmmod et insmod avec les nouveaux parametres

```
sudo insmod ./module.ko btn=18 leds=4,17
```

finalement, on peut bien vérifier le fonctionnement

```
pi@raspberrypi ~/thirion_mendieta/lab2 $ dmesg
[1029866.613523] Hello Jorge MENDIETA, Lou THIRION !
[1029866.613565] btn=18 !
[1029866.613578] LED 0 = 4
[1029866.613589] LED 1 = 17
```
### Questions :

- Comment voir que le paramètre a bien été lu ? 
    Nous pouvons afficher des messages du kernel en utilisant la fonction `printk()` afin de vérifier que le paramètre a été bien lu

## Étape 3 : création d'un driver qui ne fait rien, mais qui le fait dans le noyau

On a ajouté est 4 fonctions pour intéragir avec les leds, pour l'instant ces fonctions ne font qu'un affichage, et la structure file_operations utile à l'initialisation du module.

Nous avons dû renommer le fichier du module à `led0_MT` pour inclure nos initiaux afin d'eviter des conflicts avec les autres utilisateurs de notre carte RPI.

Après, nous avons enregistré le driver grâce la fonction `register_chrdev()` lors de la initialization du module. 

Afin de sortir propement, il faut également enlever le module des dispositifs avec `unregister_chrdev()`

```c
static int __init mon_module_init(void)
{
   major = register_chrdev(0, "led0_MT", &fops_led); // 0 est le numéro majeur qu'on laisse choisir par linux
}

static void __exit mon_module_cleanup(void)
{
   unregister_chrdev(major, "led0_MT");
}
```

cat /proc/devices | grep led0_MT

le numero majeur choisi par linux ete 246 dans notre cas

Puis, il faut créer le noeud dans `/dev` et le rendre accesible pour tous les utilisateurs afin de ne pas faire sudo a chaque fois qu'on veut exécuter le fichier.



### Questions

- Comment savoir que le device a été créé ? 
    Nous pouvons chercher sur le répertoire `/dev` et faire 
    ```
    pi@raspberrypi /dev $ ls led*
    led0_KR  led0_MT

    pi@raspberrypi /dev $ ls -l led0_MT 
    crw-rw-rw- 1 root root 246, 0 Nov 20 11:01 led0_MT
    ```

```
$ echo "rien" > /dev/led0_XY
$ dd bs=1 count=1 < /dev/led0_XY
$ dmesg | grep led0_MT
```

Grâce au string qu'on a ajouté au début de chaque message de `printk()` nous pouvons faire un grep pour trouver les messages qui appartiennet a notre module.

Nous avons crée deux scripts bash pour automatizer linsertion et suppresion du driver, puis on les a copié vers la carte

'''
[mendieta@josquin lab2]$ scp -P 62225 insdev pi@peri:thirion_mendieta
insdev                                                                             100%  255   101.5KB/s   00:00    
[mendieta@josquin lab2]$ scp -P 62225 rmdev pi@peri:thirion_mendieta
rmdev                                                                              100%  106    39.4KB/s   00:00   
'''